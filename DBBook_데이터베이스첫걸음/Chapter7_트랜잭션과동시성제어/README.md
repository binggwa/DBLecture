# 트랜잭션을 다룰 수 있는 테이블을 작성해 보자
- 실제 시스템이나 앱에서는 단일 쿼리만으로 조작하는 일은 거의 없다
- 복수의 쿼리 처리 단위를 **트랜잭션** 이라고 한다
## ACID 특성
1. Atomicity (원자성)
2. Consistency (일관성)
3. Isolation (격리성)
4. Durability (지속성)
### Atomicity
- 데이터의 변경을 수반하는 데이터 조작이 전부 성공할지 실패할지를 보증하는 구조
- 일련의 과정을 COMMIT 을 통해 처리를 확정하는데, 처리 과정에서 오류가 발생할 경우, ROLLBACK을 통해 트랜잭션의 직전 상태까지 돌아갈 수 있음
### Consistency
- 데이터 조작 전후에 상태를 유지하는 것을 보증하는 일관성
- ex) 일련번호 등
### Isolation
- 일련의 데이터 조작을 복수 사용자가 동시에 실행해도 각각의 처리가 모순없이 실행되는 것을 보증한다
- ex) SELECT와 UPDATE 사이에 다른 사용자가 SELECT를 실행하여 데이터를 확인했을 경우
- 테이블에 잠금을 걸어서 후속 처리를 블록하는 방법이 있음
- MySQL에서는 트랜잭션 처리를 할 떄 주로 행 단위의 잠금 기능을 이용함
  - SELECT ~ FOR UPDATE
  - 후속 처리는 잠금이 해제될 때까지 대기, 올바른 처리를 계속할 수 있음
- InnoDB형의 테이블은 **MVCC** 라는 구조로 동작 <- 이경우 읽기는 블록되지 않음
- 모순없이 실행된다 = 복수의 트랜잭션이 순서대로 실행되는 경우와 같은 결과를 얻을 수 있는 상태
### ANSI 4단계 격리수준
1. 커밋되지 않은 읽기 (더티, 애매, 팬텀)
2. 커밋된 읽기 (애매, 팬텀)
3. 반복 읽기 (팬텀)
4. 직렬화 가능
- 격리 수준의 완화에 따라 일어나는 현상
  - 더티 읽기
    - 어떤 트랜잭션이 커밋되기 전에 다른 트랜잭션에서 데이터를 읽는 현상 (확정 전의 더럽혀진 데이터를 읽는 느낌)
  - 애매한 읽기
    - 어떤 트랜잭션이 이전에 읽어 들인 데이터를 다시 읽어 들일 때 2회 이후의 결과가 1회 때와 다른 현상
  - 팬텀 읽기
    - 어떤 트랜잭션을 읽을 때 선택할 수 있는 데이터가 나타나거나 사라지는 현상
### Durability
- 트랜잭션 조작을 완료하고 완료 통지를 사용자가 받는 시점에서 그 조작이 영구적이 되어 결과를 잃지 않는 것
- MySQL을 포함해 많은 데이터베이스의 구현에서는 트랜잭션 조작을 하드 디스크에 로그로 기록
- 시스템에 이상이 발생하면 로그를 사용해 이상 발생 전의 상태까지 복원하는 것으로 지속성 실현
# 복수 커넥션에서 읽기와 쓰기를 하자
- prompt Transaction A>
- set transaction isolation level repeatable read;
- set transaction isolation level read committed;
## 트랜잭션 격리 수준에 따른 외관상 차이
### MVCC에 따른 MySQL의 특성
- MVCC ( Multi Versioning Concurrency Control ) <- DBMS의 주류
1. 읽기를 수행할 경우 갱신 중이라도 블록되지 않는다. (읽기와 읽기도 서로 블록되지 않는다)
2. 읽기 내용은 격리 수준에 따라 내용이 바뀌는 경우가 있다.
3. 갱신 시 배타적 잠금을 얻는다. **잠금은 기본적으로 행 단위로 얻으며 트랜잭션이 종료할 때까지 유지**한다
4. 갱신과 갱신은 나중에 온 트랜잭션이 잠금을 획득하려고 할 때 블록된다. 일정 시간을 기다리며 그사이에 잠금을 획득할 수 없는 경우에는 잠금 타임아웃이 된다.
5. 갱신하는 경우 갱신 전의 데이터를 UNDO 로그로 '롤백 세그먼트'라는 여영ㄱ에 유지한다. 이 'UNDO 로그'는 용도가 2가지
   - 첫 번째는 갱신하는 트랜잭션의 롤백 시 갱신 전으로 되돌리는 것이고,
   - 두 번째는 복수의 트랜잭션으로부터 격리 수준에 따라 대응하는 갱신 데이터를 참조하는 데 이용한다
# 잠금 타임아웃과 교착 상태
- set innodb_lock_wait_timeout = 5; : 5초동안 기다리다 오류메시지 출력
### 잠금 타임아웃이란
- 갱신과 참조는 서로 블록하지 않지만, 갱신과 갱신은 나중에 온 갱신이 잠금 대기 상태가 됨
- MySQL에서는 잠금 대기로 타임아웃이 발생하면 롤백되는 것은 기본으로 오류가 발생한 쿼리
- 트랜잭션 전체를 롤백하고 싶다면
  - 타임아웃 오류 후 명시적으로 ROLLBACK을 실행한다
  - innodb_rollback_on_timeout 시스템 변수를 설정한다
### 교착 상태
- 트랜잭션 A가 테이블 a의 잠금을 얻고, 트랜잭션 B가 테이블 b의 잠금을 얻은 뒤,
- 잠금을 유지한 채 서로 잠금을 건 자원에 잠금이 필요한 처리를 실행하면 아무리 기다려도 상황이 바뀌지 않는 상태가 됨
- 교착 상태는 상황이 개선될 가능성이 없다
- 이 때문에 일반적인 DBMS에서는 교착 상태를 독자적으로 검출해 교착 상태를 보고함
- MySQL은 교착 상태가 일어나면 시스템에 영향이 작은 쪽의 트랜잭션을 트랜잭션 개시 시점까지 롤백함
### 교착 상태의 빈도를 낮추는 대책
- 트랜잭션을 자주 커밋한다.
- 정해진 순서로 테이블에 액세스하게 한다.
- 필요 없는 경우에는 읽기 잠금 획득의 사용을 피한다.
- 쿼리에 의한 잠금 범위를 더 좁히거나 잠금 정도를 더 작은 것으로 한다.